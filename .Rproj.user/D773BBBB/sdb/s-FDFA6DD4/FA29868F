{
    "collab_server" : "",
    "contents" : "# functions for xml processing\n\n\n################\nextract_words <- function(x) { #  function to extract data from each word element in sentence. \n                               \n  words.v <-  unlist(x)\n  return  (words.v)\n}\n\n##########\n\nellip_1 <- function(x) { # function to identify tokens as ellipsis or not.\n  a <- NULL\n  b <- unlist(x)\n  c <- unlist(sent_working[15])\n  a <- append(a, \"insertion_id\" %in% names(b)) \n  \"insertion_id\" %in% names(c)\n  \n  return(a)\n}\n\n###############\n\n\nextract_edge_graph <- function(x) {\n  a <- find_heads(x)\n  b <- find_ids(x)\n  m <- matrix(a, ncol = 1)\n  m <- cbind(m, b)\n  index <- which(m[, 1] > 0)\n  m <- m[index, ]\n  if (length(m) == 2) {\n    m <- matrix(m, nrow = 1)\n  }\n  g <- graph_from_edgelist(m)\n  return(g)\n}\n\n\n\n###############\nDD_criteria <- function(x) { # function to identify tokens for which no DD should be figured.\n  \n  word.v <- NULL \n \n  word.v <- append(word.v, as.numeric(x[\"head\"]) == 0) # Nodes dependent on 0 (sentence root, etc) have no DD.\n  \n  # a set of lines to catch punctuation; no DD should be figured for punctuation marks. This code is somewhat redundant,\n  # since it checks for relation values commonly assigned to punctuation and also checks part of speech attribute\n  # for value \"punctuation.\"\n  word.v <- append(word.v, x[\"relation\"] == \"AuxX\") # If node is comma, assign TRUE.\n  word.v <- append(word.v, x[\"relation\"] == \"AuxK\") # If node is sentence final punctuation, assign TRUE.\n  word.v <- append(word.v, x[\"relation\"] == \"AuxG\") # If node is bracketing punctuation, assign TRUE.\n  word.v <- append(word.v, substr(x[\"postag\"], 1, 1) == \"u\") # If part of speech is \"punctuation\", mark TRUE.\n  \n  \n  word.v <- append(word.v, \"insertion_id\" %in% names(x)) # Nodes that are ellipses have no DD.\n  word.v <- append(word.v, node.list$Ellipsis[as.numeric(x[\"head\"])]) # Nodes dependent on ellipses have no DD. This assessment\n                                                              # requires ellipsis.v as input. That vector is the output of\n                                                              # function ellip_1().\n  \n  \n  # return(as.logical(word.v))\n  \n  if (TRUE %in% word.v) { # Checks word.v for any TRUE value.  Such a value disqualifies node from DD calculation.\n    return(FALSE) # Node does NOT qualify for DD calculation.\n  } else\n    return(TRUE) # Node may be used in DD calculation.\n  \n}\n#####################\n\nfind_punct_index <- function(x) { # A function to return id values of each punctuation mark in sentence.\n  word.v <- NULL\n  word.v <- append(word.v, x[\"relation\"] == \"AuxX\") # If node is comma, assign TRUE.\n  word.v <- append(word.v, x[\"relation\"] == \"AuxK\") # If node is sentence final punctuation, assign TRUE.\n  word.v <- append(word.v, x[\"relation\"] == \"AuxG\") # If node is bracketing punctuation, assign TRUE.\n  # word.v <- append(word.v, substr(x[\"postag\"], 1, 1) == \"u\") # If part of speech is \"punctuation\", mark TRUE.\n  \n  a <- NULL\n  if (TRUE %in% word.v) { \n    return(as.numeric(x[\"id\"]))\n  }\n  \n}\n\n\n\n\n#####################\n\nDD_calculation <- function(x) { # A function to calculate DD for each eligible node.\n  a <- NULL\n  word.v <- NULL\n  word.v <- append(word.v, as.numeric(x[\"head\"]) == 0) # Nodes dependent on 0 (sentence root, etc) have no DD.\n  \n  # a set of lines to catch punctuation; no DD should be figured for punctuation marks. This code is somewhat redundant,\n  # since it checks for relation values commonly assigned to punctuation and also checks part of speech attribute\n  # for value \"punctuation.\"\n  word.v <- append(word.v, x[\"relation\"] == \"AuxX\") # If node is comma, assign TRUE.\n  word.v <- append(word.v, x[\"relation\"] == \"AuxK\") # If node is sentence final punctuation, assign TRUE.\n  word.v <- append(word.v, x[\"relation\"] == \"AuxG\") # If node is bracketing punctuation, assign TRUE.\n  word.v <- append(word.v, substr(x[\"postag\"], 1, 1) == \"u\") # If part of speech is \"punctuation\", mark TRUE.\n  \n  \n  word.v <- append(word.v, \"insertion_id\" %in% names(x)) # Nodes that are ellipses have no DD.\n  word.v <- append(word.v, node.list$Ellipsis[as.numeric(x[\"head\"])]) # Nodes dependent on ellipses have no DD. This assessment\n  # requires ellipsis.v as input. That vector is the output of\n  # function ellip_1().\n  \n  node_DD.v <- NULL\n  \n  \n  if (TRUE %in% word.v) { # do not calculate DD\n    \n    node_DD.v <- NA\n    \n  } else {\n    # p.holder.v <- length(seq(heads.v[k], ids.v[k])) - length(setdiff(seq(heads.v[k], ids.v[k]), punct.index.v))\n    a <-  length(seq(as.numeric(x[\"head\"]), as.numeric(x[\"id\"]))) - length(setdiff(seq(as.numeric(x[\"head\"]), as.numeric(x[\"id\"])),\n                                                                                   punct.index.v))\n    \n    if (as.numeric(x[\"head\"]) > as.numeric(x[\"id\"])) { # Selects for a head node that follows the child node.\n      a <- as.numeric(x[\"head\"]) - (as.numeric(x[\"id\"]) + a)  # Effectively moves child node (the subtrahend) closer in value to the head.\n      \n      if (a > 6) {\n        node_DD.v <- append(node_DD.v, \"GT6\")\n        \n      } else {\n        \n        node_DD.v <- append(node_DD.v, a)\n      }\n      \n    } else { # Selects for a head node that precedes the child node.\n      # p.holder.v <- (heads.v[k] + p.holder.v) - ids.v[k] # Effectively moves head node (the minuend) closer in value to the child.\n      \n      a <- (as.numeric(x[\"head\"]) + a) - as.numeric(x[\"id\"]) # Effectively moves head node (the minuend) closer in value to the child.\n      if ( a < (0 - 6 )) {\n        \n        node_DD.v <- append(node_DD.v, \"LT-6\")\n        \n      } else {\n        \n        node_DD.v <- append(node_DD.v, a)\n      }\n      \n    }\n    \n    # if (heads.v[k] > ids.v[k])  { # Tests whether head node follows child node.\n    \n    \n    \n  }\n  \n  return(node_DD.v)\n  \n} # end of DD_calculation() function.\n\n\n\n\n##################\n\nfind_heads <- function(x) {\n  a <- unlist(sent_working)\n  \n  a <-  unlist(a)  [which(names(unlist(a)) == \"word.head\")]\n  a <- as.numeric(a)\n  return(a)\n}\n\n\n\n\nfind_ids <- function(x) {\n  a <- unlist(sent_working)\n  \n  a <-  unlist(a)  [which(names(unlist(a)) == \"word.id\")]\n  a <- as.numeric(a)\n  return(a)\n}\n\n\nneighborhood_extraction <- function(x) {\n  \n  if (as.numeric(x[\"id\"]) <= length(neighborhood.l) \n      & as.numeric(x[\"id\"]) <= length(node.list$Subtree_eligibility))  {\n    \n    if (node.list$Subtree_eligibility[[as.numeric(x[\"id\"])]] == TRUE) {\n      a <- neighborhood.l[[as.numeric(x[\"id\"])]]\n      a <- a <- paste0(a, sep=\"\", collapse = \" \")\n      \n    } else {\n      a <- NA\n    }\n    \n    \n  } else {\n    \n    a <- NA\n    \n    \n  }\n  \n\n  return(a)\n}\n\n\n\nSubtree_criteria <- function(x) { # function to identify tokens for which no DD should be figured.\n  \n  word.v <- NULL \n  \n  \n  # a set of lines to catch punctuation; no DD should be figured for punctuation marks. This code is somewhat redundant,\n  # since it checks for relation values commonly assigned to punctuation and also checks part of speech attribute\n  # for value \"punctuation.\"\n  word.v <- append(word.v, x[\"relation\"] == \"AuxX\") # If node is comma, assign TRUE.\n  word.v <- append(word.v, x[\"relation\"] == \"AuxK\") # If node is sentence final punctuation, assign TRUE.\n  word.v <- append(word.v, x[\"relation\"] == \"AuxG\") # If node is bracketing punctuation, assign TRUE.\n  \n  \n  if (TRUE %in% word.v) { # Checks word.v for any TRUE value.  Such a value disqualifies node from DD calculation.\n    return(FALSE) # Node does NOT qualify for DD calculation.\n  } else\n    return(TRUE) # Node may be used in DD calculation.\n  \n}\n\n\nsubtree_extraction <- function(x) {\n  \n  if (as.numeric(x[\"id\"]) <= length(subtree.l)\n      & as.numeric(x[\"id\"]) <= length(node.list$Subtree_eligibility)) {\n    \n    if (node.list$Subtree_eligibility[[as.numeric(x[\"id\"])]] == TRUE) {\n      a <- subtree.l[[as.numeric(x[\"id\"])]]\n      a <- a <- paste0(a, sep=\"\", collapse = \" \")\n      \n    } else {\n      a <- NA\n    }\n    \n    \n  } else {\n    \n    a <- NA\n    \n  }\n \n  return(a)\n}\n\npopulate_word_element <- function(x) {\n  word.xml <- xmlNode(\"word\") # create word xml node\n  word.xml <- addAttributes(word.xml, id = x[\"id\"], form = x[\"form\"], lemma = x[\"lemma\"], postag = x[\"postag\"],\n                            elation = x[\"relation\"], head = x[\"head\"], cite = x[\"cite\"])\n  \n  return(word.xml)\n}\n\npunc_in_gap <- function(x) {\n  a <- NULL\n  a <- append(a, x %in% punct.index.v)\n  return(a)\n  \n}\n\n\nellipis_in_gap <- function(x) {\n  a <- NULL\n  a <- append(a, ! (\"insertion_id\"  %in% names(x)) )\n  \n}\n\n\nprojectivity_extraction <- function(x) {\n  \n  \n  if (as.numeric(x[\"id\"]) <= length(subtree.l) & node.list$Projectivity_eligibility[[as.numeric(x[\"id\"])]] == TRUE & \n      (length(node.list$Subtree[as.numeric(x[\"id\"])]) > 0)) {\n    \n    if (! (\"insertion_id\" %in% names(x)) & (length(node.list$Subtree[as.numeric(x[\"id\"])]) = 1)) {\n      \n      a <- strsplit(node.list$Subtree[as.numeric(x[\"id\"])], \" \")\n      a <- as.numeric(a)\n      a <- unlist(a)\n      b <- min(a, na.rm = TRUE) : max(a, na.rm = TRUE)\n      c <- setdiff(b, a)\n      d <- sapply(c, punc_in_gap)\n      d <- append(d, sapply(x, ellipis_in_gap))\n      \n      # a <- unlist(strsplit(node.list$Subtree[as.numeric(x[\"id\"])], \" \"))\n      # a <- as.numeric(a)\n      # b <- min(a, na.rm = TRUE) : max(a, na.rm = TRUE)\n      # c <- setdiff(b, a)\n      # d <- sapply(c, punc_in_gap)\n      # d <- append(d, sapply(x, ellipis_in_gap))\n      \n      if (FALSE %in% d) {\n        e <- \"NonProjective\"\n      } else {\n        \n        e <- \"Projective\"\n        \n      }\n      \n    }\n    \n  } else {\n    \n    e <- NA\n  }\n  \n}\n\n\n\nprojectivity_eligibility <- function(x) {\n  a <- NULL\n  a <- append(a, x[\"relation\"] == \"AuxX\")\n  a <- append(a, x[\"relation\"] == \"AuxK\")\n  a <- append(a, x[\"relation\"] == \"AuxG\")\n  a <- append(a, \"insertion_id\" %in% names(x))\n  \n  if (TRUE %in% a) {\n    \n    return(FALSE)\n  } else {\n    \n    return(TRUE)\n  }\n  \n}\n\n\nrel_extraction <- function(x)  {\n  a <-  sent_working[[x]][\"relation\"]\n}\n\npos_extraction <- function(x)  {\n  a <-  sent_working[[x]][\"postag\"]\n}\n\nrel_pos_extraction <- function(x) {\n  a <- sent_working[[x]][\"relation\"]\n  b <- substr(sent_working[[x]][\"postag\"], 1, 1)\n  c <- paste(a, b, sep = \"-\")\n  \n}\n\n\n\nneighborhood_values_extraction <- function(x) {\n  \n  result <- NULL\n  \n  if (node.list$Subtree_eligibility[as.numeric(x[\"id\"])] == TRUE)  {\n    \n    a <-  strsplit(node.list$Neighborhood[as.numeric(x[\"id\"])], \" \")\n    a <- sapply(a, as.numeric)\n   \n    \n    holder1 <- NULL\n    holder2 <- NULL\n    holder3 <- NULL\n    \n    \n    if (length(a) == 1) {\n      \n      \n      result <- \"NA\"\n      \n    } else { # neighborhood with more than 1 member\n      \n      self <- a[1]\n      # a <- a[2:length(a)]\n      a <- sort(a)\n      \n      e <-  sapply (a, rel_extraction)\n      index <- which(a == self)\n      e[index] <- paste(\"self\", e[index], sep = \".\" )\n     \n      \n      holder1 <- e\n      \n      holder1 <- paste(holder1, collapse = \"-\")\n      \n      \n      \n      h <- sapply (a, pos_extraction)\n      i <- substr(h, 1,1)\n      i[index] <- paste(\"self\", i[index], sep = \".\" )\n      \n      holder2 <- i\n     \n      holder2 <- paste(holder2, collapse = \"-\")\n      \n      \n      # result <-  paste(result, collapse = \"-\")\n      \n      k <- sapply(a, rel_pos_extraction)\n      k[index] <- paste(\"self\", k[index], sep = \".\" )\n     \n      holder3 <- k\n     \n      holder3 <- paste(holder3, collapse = \"-\")\n      \n      result <- append(holder1, holder2)\n      result <- append(result, holder3)\n      \n      \n      return(result)\n      \n    }\n    \n  } else {\n    \n    return(\"NA\")\n  }\n  \n}\n\nabs_DD_calculation <- function(x) { # A function to calculate DD for each eligible node.\n  a <- NULL\n  word.v <- NULL\n  word.v <- append(word.v, as.numeric(x[\"head\"]) == 0) # Nodes dependent on 0 (sentence root, etc) have no DD.\n  \n  # a set of lines to catch punctuation; no DD should be figured for punctuation marks. This code is somewhat redundant,\n  # since it checks for relation values commonly assigned to punctuation and also checks part of speech attribute\n  # for value \"punctuation.\"\n  word.v <- append(word.v, x[\"relation\"] == \"AuxX\") # If node is comma, assign TRUE.\n  word.v <- append(word.v, x[\"relation\"] == \"AuxK\") # If node is sentence final punctuation, assign TRUE.\n  word.v <- append(word.v, x[\"relation\"] == \"AuxG\") # If node is bracketing punctuation, assign TRUE.\n  word.v <- append(word.v, substr(x[\"postag\"], 1, 1) == \"u\") # If part of speech is \"punctuation\", mark TRUE.\n  \n  \n  word.v <- append(word.v, \"insertion_id\" %in% names(x)) # Nodes that are ellipses have no DD.\n  word.v <- append(word.v, node.list$Ellipsis[as.numeric(x[\"head\"])]) # Nodes dependent on ellipses have no DD. This assessment\n  # requires ellipsis.v as input. That vector is the output of\n  # function ellip_1().\n  \n  node_DD.v <- NULL\n  \n  \n  if (TRUE %in% word.v) { # do not calculate DD\n    \n    node_DD.v <- NA\n    \n  } else {\n    \n    \n    a <-  length(seq(as.numeric(x[\"head\"]), as.numeric(x[\"id\"]))) - length(setdiff(seq(as.numeric(x[\"head\"]), as.numeric(x[\"id\"])),\n                                                                                   punct.index.v))\n    \n    if (as.numeric(x[\"head\"]) > as.numeric(x[\"id\"])) { # Selects for a head node that follows the child node.\n      \n      a <- as.numeric(x[\"head\"]) - (as.numeric(x[\"id\"]) + a)  # Effectively moves child node (the subtrahend) closer in value to the head.\n      node_DD.v <- append(node_DD.v, a) \n      \n    } else { # Selects for a head node that precedes the child node.\n      # p.holder.v <- (heads.v[k] + p.holder.v) - ids.v[k] # Effectively moves head node (the minuend) closer in value to the child.\n      \n      a <- (as.numeric(x[\"head\"]) + a) - as.numeric(x[\"id\"]) # Effectively moves head node (the minuend) closer in value to the child.\n      \n      \n      node_DD.v <- append(node_DD.v, a)\n      \n      \n    }\n    \n  }\n  \n  return(abs(node_DD.v))\n  \n} # end of DD_calculation() function.\n\nellipsis_identification <- function(x) {\n  \"insertion_id\" %in% names(x)\n}\n\n\npopulate_word_element <- function(x) {\n  y <- as.numeric(x[\"id\"])\n  word.xml <- xmlNode(\"word\") # create word xml node\n  \n  if (node.list$Ellipsis[y] == FALSE) {\n    \n    word.xml <- addAttributes(word.xml, id = x[\"id\"], form = x[\"form\"], lemma = x[\"lemma\"], postag = x[\"postag\"],\n                              relation = x[\"relation\"], head = x[\"head\"], cite = x[\"cite\"], Subtree = node.list$Subtree[y],\n                              \n                              DepDist = node.list$DepDist[y],\n                              Neighborhood = node.list$Neighborhood[y])\n    \n  } else {\n    \n    word.xml <- addAttributes(word.xml, id = x[\"id\"], form = x[\"form\"], lemma = x[\"lemma\"], postag = x[\"postag\"],\n                              relation = x[\"relation\"], head = x[\"head\"], cite = x[\"cite\"], insertion_id = x[\"insertion_id\"],\n                              artificial = x[\"artificial\"], Subtree = node.list$Subtree[y],\n                             \n                              DepDist = node.list$DepDist[y],\n                              Neighborhood = node.list$Neighborhood[y])\n    \n  }\n  \n  return(word.xml)\n}\n\n\n\ncheck_gap_heads <- function(x, arg2, arg3) {\n  result <- NULL\n  a <- sent_working[[x]][\"head\"]\n  b <- as.numeric(a)\n  result <- append(result, ((b > 0) & (b < arg2)) | b > arg3)\n  \n}\n\n\ngap_extraction <- function(x) {\n  y <- as.numeric(x[\"id\"])\n  if (node.list$Projectivity_eligibility[[as.numeric(x[\"id\"])]] == TRUE) {\n    a <- as.numeric(unlist(strsplit(node.list$Neighborhood[y], \" \")))\n    gap_min <- min(a)\n    gap_max <- max(a)\n    c <- seq(gap_min, gap_max)\n    d <- which(! c %in% a)\n    e <- c[d]\n    \n    result <- sapply(e, check_gap_heads, arg2=gap_min, arg3=gap_max)\n    if (TRUE %in% result) {\n      return(\"NonPlanar\")\n    } else {\n      return(\"Planar\")\n    }\n    \n  } else {\n    return(NA)\n  }\n}\n\n\ncheck_ancestors <- function(x, id) {\n  a <-  as.numeric(unlist(strsplit(node.list$Subtree[x], \" \")))\n  b <- id %in% a\n}\n\n\n\nfind_ill_nested <- function(x, arg2) {\n  if (length(which(node.list$Planarity == \"NonPlanar\")) >= 2) {\n    y <- as.numeric(x[\"id\"])\n    if (node.list$Planarity[y] == \"NonPlanar\") {\n      a <- as.numeric(unlist(strsplit(node.list$Neighborhood[y], \" \")))\n      gap_min <- min(a)\n      gap_max <- max(a)\n      c <- seq(gap_min, gap_max)\n      d <- which(! c %in% a)\n      e <- c[d] \n      f <- as.numeric(arg2[e][\"head\"])\n      g <- append(e, f)\n      \n      result <- sapply(g, check_ancestors, id = y)\n      \n      if (TRUE %in% result) {\n        return(\"WellNested\")\n      } else {\n        return(\"IllNested\")\n        \n      }\n      \n    } else {\n      return(\"WellNested\")\n    }\n  } else {\n    return(\"WellNested\")\n  }\n}\n\n",
    "created" : 1510425363425.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "898018618",
    "id" : "FA29868F",
    "lastKnownWriteTime" : 1510441326,
    "last_content_update" : 1510441326,
    "path" : "~/SyntaxMetrics/R_files/code/combinations/DD_functions.R",
    "project_path" : "DD_functions.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}