{
    "collab_server" : "",
    "contents" : "rm(list = ls())\n\nsource(\"./DD_functions.R\")\n\nrequire(XML)\nrequire(igraph)\n\n\n\n\n# Identify directory with the input files.\ninput.dir <- \"./input_1\"\n\n# Identify directory for the output files.\noutput.dir <- \"./ouput_1\"\n\n\nfiles.v <- dir(path=input.dir, pattern=\".*xml\") # A vector with each file name from input directory.\ntoken.number.l <- list()\nDD.l <- list() # unclear: what does this list do???\nnode.DD.l <- list() # unclear: what does this list do???\ni <- 33\nj <- 1\n\nfiles.v[i]\n\nptm <- proc.time()\n\nfor (i in seq_along(files.v)) {\n  \n  doc <- xmlParse(file.path(input.dir, files.v[i]))  # create object with full xml of tree file. \n  \n  sentence.nodes <- getNodeSet(doc, \"//sentence\") # extract setences from full tree xml\n  \n  sentence.list <- xmlApply(sentence.nodes, xmlToList) # convert nodes to list object\n  \n  subtree.xml <- xmlNode(\"subTree_document\") # create root node for new xml document\n  \n  \n  \n  \n  for (j in 1:length(sentence.list)) {\n    \n    \n    \n    \n    sent_working <- lapply(sentence.list[[j]][1:length(sentence.list[[j]])  -1], extract_words) # extract target sentence \n    # with tokens as items in list object.\n    \n    node.list <- vector(\"list\", 5)\n    names(node.list) <- c(\"Ellipsis\", \"Subtree_eligibility\", \"Subtree\", \n                           \"DepDist\", \"Neighborhood\")\n    \n    \n    node.list$Ellipsis <- sapply(sent_working, ellipsis_identification) # logical vector with TRUE for each ellipsis node in target sentence\n    # vector is necessary input for function DD_criteria().\n    \n    punct.index.v <- unlist(lapply(sent_working, find_punct_index))\n    \n    edge.graph  <- extract_edge_graph(sent_working) # create graph object (package = \"igraph\") from sent_working.\n    \n    \n    subtree.l <- ego(edge.graph, 50, mode = \"out\") # List of elements; each element contains id values\n    # for subtree of given node. A subtree is the given node\n    # and its direct AND indirect dependents.\n    \n    neighborhood.l <- ego(edge.graph, 1, mode = \"out\") # List of elements; each element contains id values\n    # for neighborhood of given node. A neighborhood is\n    # a given node and its direct dependents ONLY.\n    \n    \n    node.list$DepDist <- sapply(sent_working, DD_calculation) # produces a  vector; this mode is suitible for insertion as \n    # values of attributes in word elements of the XML output.\n    \n    node.list$Subtree_eligibility <-  sapply(sent_working, Subtree_criteria)\n    \n    node.list$Neighborhood <- sapply(sent_working, neighborhood_extraction)\n    \n   # node.list$Projectivity_eligibility <- sapply(sent_working, projectivity_eligibility)\n    \n    node.list$Subtree  <- sapply(sent_working, subtree_extraction)\n    \n   # node.list$Projectivity <- sapply(sent_working, projectivity_extraction)\n    \n   # node.list$Planarity <- sapply(sent_working, gap_extraction)\n    \n   # node.list$Neighborhood_values <- sapply(sent_working, neighborhood_values_extraction)\n    \n   \n    \n    # sentence_P <- if(\"NonProjective\" %in% node.list$Projectivity) {\n    #   \"NonProjective\"\n    # } else {\n    #   \"Projective\"\n    # }\n    # \n    # sentence_Pl <- if (\"NonPlanar\" %in% node.list$Planarity) {\n    #   \"NonPlanar\"\n    # } else {\n    #   \"Planar\"\n    # }\n    \n    sentence_DD <- round(mean(sapply(sent_working, abs_DD_calculation), na.rm = TRUE), digits = 4 )\n    \n    token_number <- length(sent_working)\n    \n    \n    a <- unlist(sentence.list[[j]][length(sentence.list[[j]])]) # make vector of sentence attributes.\n    # sentence attributes appear in last sublist of each list\n    # in sentence.list. This list is accessed using \n    # length(sentence.list[[j]]).\n    \n    sent.xml <- xmlNode(\"sentence\") # create sentence node\n    \n    sent.xml  <-  addAttributes(sent.xml, id = a[\".attrs.id\"], \n                                document_id = a[\".attrs.document_id\"], \n                                stand_ref = a[\".attrs.stand_ref\"],\n                                subdoc = a[\".attrs.subdoc\"], span = a[\".attrs.span\"],\n                                \n                                Mean_DepDist = sentence_DD,\n                                Sentence_length = token_number) \n    \n    \n    \n    sent.xml <- append.xmlNode(sent.xml, lapply(sent_working, populate_word_element))\n    \n    subtree.xml <- append.xmlNode(subtree.xml, sent.xml) # Insert sentence into document xml.\n    \n    token.number.l[[j]] <-  token_number\n    \n  } # end of loop j\n  \n j <- 1\n token.number.l <- list()\n saveXML(subtree.xml, paste0(\"./output_1/\", files.v[i]))\nprint(files.v[i]) \nprint(Sys.time())\n\n\n  \n} # end of loop i\n\n\n\nproc.time() - ptm\n\nsubtree.xml[2]\n\n\n\n\nsaveXML(subtree.xml, paste0(\"./output_1/\", files.v[i]))\n\n\n",
    "created" : 1510424908388.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4252112978",
    "id" : "915305CC",
    "lastKnownWriteTime" : 1510602826,
    "last_content_update" : 1510602826253,
    "path" : "~/SyntaxMetrics/R_files/code/xml_extraction/re-fact_with_functions.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}